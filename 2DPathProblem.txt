Problem Description: 

Write a Python function that determines whether a path exists between two points that only crosses black pixels. Define a path as a sequence of pixels
such that each pixel in the path is adjacent to the next pixel in the path. 

Solution Description: 

This problem is solved as an X Y axis traversal problem. 

User defined values are 
  * the 2D Environment size: NxM 
    example:[4,4] is a square N=4, M=4 matrix of random 0,1 values 
  * start_position within array = [x1,y1] 
  * end_position within array = [x2,y2]
  * flag_value = 1

Given user defined inputs of the 2D Environment size and start and end positions, the program will create a 2D Enviroment of the user defined values
N x M with random 0,1 values. The axis distances across the X and Y axis are determined in each axis direction. 

Path Determination Approach: First, a function, axis_steps, takes the difference in the axis movements: Y2-Y1 and X2-X1 to determine 
axis distance ranges. Using the distances, a dictionary of step movements are created for both the X and Y axis. 
A function, build_xy_path_dic, is used to iterate through the two axis step dictionaries using a larger one if exists as at the bound and populates 
different path potentials from A to B. This is done by a permutation approach of adding X and Y and then Y then X to each previous step. 

There is also a function, produce_xmax_ymax_path_ymax_max_path, to produce the maximum path first along the X axis 
and then along the Y axis and again, first along the Y axis and then along the X axis. This will be used in combination 
with the XY combination paths for a complete path set. 

All possible paths produced are combined to generate the a list of the possible paths of index values. Finally, out of the list of possibilies
of index value paths, it is determined if there exist one of only the flag value, i.e a path of all 1's.




import numpy as np

# User Defined values of 2D Enviroment size, the start and end positions and flag_value 
N = 5
M = 6
start_position = [1,1]
end_position = [3,3]
flag_val = 1



# Build out matrix
array = np.random.choice([0,1],[N,M])

# Determine difference in X and Y steps needed 
start_position_x = start_position[0]
start_position_y = start_position[1] 

end_position_x = end_position[0]
end_position_y = end_position[1]

# Number of Steps: in the X axis and Y axis directions  
n_x_steps = end_position_x - start_position_x 
n_y_steps = end_position_y - start_position_y 

# Build out dictionary of X steps and Y steps 
x_dic_steps = {}
y_dic_steps = {}

for i in range(0,n_x_steps):
    i=i+1
    pos_i_x = [start_position_x + i , start_position_y]
    x_dic_steps[i] = pos_i_x

for i in range(0,n_y_steps):
    i=i+1
    pos_i_y = [start_position_x, start_position_y+i]
    y_dic_steps[i] = pos_i_y


'''
Function Description: Intakes a dictionary and outputs an array of steps in order to be applied to 
    produce:
        X_MAX,Y_MAX paths
        Y_MAX,X_MAX paths 

Input: Dictionary of steps
Output: Iterated list of steps along an axis direction  
'''

def axis_steps(dic):

    size_dic = len(dic.keys())
    i_pos_path = [] 
    
    for i in range(0,size_dic):
        i=i+1
        i_position = dic[i]
        i_pos_path.append(i_position)
        
    return i_pos_path



'''
Function Description: Intakes both X and Y dictionaries to produce two paths:
    XMAX_YMAX = The path formed when traversing first the maximum path value along only the X axis first followed by Y traversal 
    YMAX_XMAX = The path formed when traversiing first the maximum path value along only the Y axis first followed by X traversal 

    Both will be used in final path possible combinations and appened to paths when switching between X and Y axis moves 
    Note: Total paths should be 2 + N_steps*2 = max path in x then y + max path in y then x + N_steps*2 where 2 is the choice selection of X or Y

Input: X step dictionary, Y step dictionary, axis_step function
Output: List containing two paths: [XMAX_YMAX, YMAX_XMAX]
'''

def produce_xmax_ymax_path_ymax_max_path(dic_x, dic_y, axis_steps):

    x_max = []
    y_max = [] 
    
    y_path = axis_steps(dic_y)
    x_path = axis_steps(dic_x)  
    
    
    for i in x_path:
        x_max.append(i)
    
    for j in y_path:
        y_max.append(j)
    
    xy_max = [] 
    yx_max = [] 
    
    for i in x_max:
        xy_max.append(i)
        
    for j in y_max:    
        xy_max.append(j)
        yx_max.append(j)
        
    for k in x_max:
        yx_max.append(k)

    xy_max_yx_max_paths = [
                            xy_max,
                            yx_max
                            ] 
    return xy_max_yx_max_paths


'''
 Function Description: Building out the XY combination path dictionary
          Logic takes the larger of the two dicionaries to determine key path set up
          Iterate through the larger dictionary up to the size of the smaller
          Then proceed forward only with the larger dictionary values adding on to the built out dictionary in the preceeding steps

 
 Input: X Step Dictionary,  Y Step Dictionary 
 Output: Dictionary of the different XY path combinations from start_position to end_position
         This will need to be combined with the two paths that comprise going only along the maximum direction of X then Y and Y then X
         

Example:

For each dictionary key, store the combination set of appending 
                            an xy_step to all previous lists 
                            an yx_step to all previous lists

path_dic_1_step = {[1]:  [[0,1],[1,0]],
                         [[1,0],[0,1]]
                }


            
path_dic_2_Steps           {[1]: [[0,1],[1,0]],
                                 [[1,0],[0,1]],
                                 
                            [2]: [[0,1],[1,0],[0,2],[2,0]],
                                 [[1,0],[0,1],[0,2],[2,0]],
                                 [[0,1],[1,0],[2,0],[0,2]],
                                 [[1,0],[0,1],[2,0],[0,2]]
                    
                            }

path_dic_2_Steps           {[1]: [[0,1],[1,0]],
                                 [[1,0],[0,1]],
                                 
                            [2]: [[0,1],[1,0],[0,2],[2,0]],
                                 [[1,0],[0,1],[0,2],[2,0]],
                                 [[0,1],[1,0],[2,0],[0,2]],
                                 [[1,0],[0,1],[2,0],[0,2]],

                            # all of step two values appending xy_i step and all of step values appending yx_i step
                            [3]:
                             
                    
                            }

            
'''


def build_xy_path_dic(y_dic_steps, x_dic_steps):
    
    size_steps_y = len(y_dic_steps.keys())
    size_steps_x = len(x_dic_steps.keys())
    
    paths = {}
    path_dic = {}
    
    if size_steps_y >= size_steps_x:  
        for i in range(0, size_steps_y):
            i=i+1
            
            if i <= size_steps_x:
                a_step_i = y_dic_steps[i]
                b_step_i = x_dic_steps[i]
                
                ab_i = [a_step_i] + [b_step_i]
                ba_i = [b_step_i] + [a_step_i]
                
                if len(path_dic.keys()) == 0:
                    path_dic[i] = [ab_i,ba_i]
                                  
                else:
                    path_lists = path_dic[i-1] 
                
                    # intialize empty new path list to combine lists and store in dic[i+1] key 
                    new_list = [] 
                    for j in path_lists:
                        new_list.append(j + ab_i)
                    for j in path_lists:
                        new_list.append(j + ba_i)
                
                    path_dic[i] = new_list
            
            else:
                # Then we have  j > i so only dealing with larger dic just look at  
                y_j = y_dic_steps[i]
                
                path_lists = path_dic[i-1]
                new_list = [] 
                for path in path_lists:
                    new_list.append(path + [y_j])
                
                path_dic[i] = new_list
                    
    return path_dic

'''
Function Description: Intakes a list of indexes and numpy array to produce a list of values per index within the array
                        This will be used to determine if there exist a possible path from start to end of only the flag value 

Input: Path_list, 2D Array Environment 
Output: List of index values 

'''
def produce_index_path_values(path_list, array):

    array_path_values = [] 
    n_index = len(path_list)

    for i in range(0,n_index):
        index_0_val = path_list[i][0]
        index_1_val = path_list[i][0]
        array_index_value = array[index_0_val, index_1_val] 
        array_path_values.append(array_index_value)
        
    return array_path_values 

    

xy_max_yx_max_paths = produce_xmax_ymax_path_ymax_max_path(x_dic_steps, y_dic_steps, axis_steps)

n_x_steps = len(x_dic_steps.keys())
n_y_steps = len(y_dic_steps.keys())

if n_x_steps >= n_y_steps:
    xy_path_dic = build_xy_path_dic(x_dic_steps , y_dic_steps)
    
if n_y_steps >  n_x_steps:
    xy_path_dic = build_xy_path_dic(y_dic_steps, x_dic_steps)


# Last key is the full list of combo paths
size_xy_path_dic = len(xy_path_dic.keys())

paths = xy_path_dic[size_xy_path_dic]

index_value_paths = []

for i in range(0,len(paths)):
    path_i = paths[i]
    path_i.insert(0,start_position) 
    path_i.append(end_position)
    index_value_paths.append(path_i) 


'''
Given the possible path combinations add the start and end position to get the complete index value path 
'''

xy_max_path = xy_max_yx_max_paths[0]
yx_max_path = xy_max_yx_max_paths[1]

xy_max_path.insert(0,start_position)
xy_max_path.append(end_position)

yx_max_path.insert(0,start_position)
yx_max_path.append(end_position)

'''
Two paths of maximum Y movement then maximum X movement 
'''
yx_path_values = produce_index_path_values(yx_max_path, array)
xy_path_values = produce_index_path_values(xy_max_path, array)

path_values = [] 
n_paths = len(index_value_paths)

'''
N paths of XY -> YX combintions formations
'''

for i in range(0,n_paths):
        
        path_i = index_value_paths[i]

        # for this index path_i, get the associated array_index_values; store in a list
        path_i_values = produce_index_path_values(path_i, array)
        path_values.append(path_i_values)

''' 
Get all paths of the index_values: 2 paths of maximum X and Y movements + N combinations paths 
'''
all_index_values_paths = [] 
all_index_values_paths.append(yx_path_values)
all_index_values_paths.append(xy_path_values)

for path in path_values:
   all_index_values_paths.append(path)

'''
Check to see if all values within a path are the flag_value
'''
path_all_flag_value = [] 

for index_values_path in all_index_values_paths:
    if all(v == flag_val for v in index_values_path):
        path_all_flag_value.append(index_values_path)

total_paths = len(all_index_values_paths)
total_paths_only_all_flag_value = len(path_all_flag_value)

print("Total paths:", total_paths)
print("Total Paths Only Flag Value:", total_paths_only_all_flag_value, "Flag_value:", flag_val) 


if total_paths_only_all_flag_value > 0:
    print("True")
    print("Total possible paths all flag_value:",total_paths_only_all_flag_value)
    print("Total Paths Possible:",total_paths)
else:
    print("False", total_paths_only_all_flag_value)
    print("Total Paths POssible:", total_paths) 



# Check of the paths of index values 
for index_values_path in all_index_values_paths:
    print(index_values_path)


# Check of 2D Envirnment 
array
          
